# TODO: stuff to add / fix 
# [ ] Unit Tests
# [ ] Flask routes should be apart of a blueprint that we import into our main file
# [ ] See if we can do a similar blueprint thingy with the socketio routes too

"""
SERVER:
-------------------------------------------------
# Room keys:
Should maybe be generated by hash(username, datetime) 
if that makes sense, otherwise do it a different way
should not be deleted when emptied
instead maybe routinely delete unused room data?
-------------------------------------------------
# Robust Reconnections
I have no idea how this will turn out
-------------------------------------------------
# Username should be give on connection
-------------------------------------------------
"""

import random
import sqlite3

import socketio
from random import randrange
from flask import Flask
from flask import g
from flask import request

pp = Flask(__name__)

sio = socketio.Server(cors_allowed_origins="http://localhost:3000")
app = socketio.WSGIApp(sio, pp)

# Custom rooms built on top of sio, I think this is necessary but maybe the docs just suck
from rooms import RoomTracker
room_tracker = RoomTracker(sio)

# -- Socket Events --
@sio.event
def connect(sid, environ):
  print(f"Connected: {sid}")

# TODO: maybe don't delete room immediately on disconnection, this breaks things 
#       if only one person is in the room, leaves then reconnects
@sio.event
def disconnect(sid):
  rooms_to_leave = [room for room in sio.rooms(sid) if room != sid]
  print(f"rooms to leave: {' '.join(rooms_to_leave)}") #Debug, remove when done
  for room in rooms_to_leave:
    room_members = [get_username(member_sid) for member_sid in room_tracker.leave(sid, room)]
    sio.emit("update_lobby", {"members" : room_members}, room=room, skip_sid=sid)
  print(f"Disconnected: {sid}")

@sio.event
def join_room(sid, data):
  username, room_key = data["username"], data["room_key"]
  with sio.session(sid) as session:
    session['username'] = username
  sids = list(room_tracker.enter(sid, room_key))
  room_members = [get_username(member_sid) for member_sid in sids]
  sio.emit("update_lobby", {"members" : room_members}, room=room_key)

@sio.event
def start_game(sid):
  room_key = [room for room in sio.rooms(sid) if room != sid][0]
  room_tracker.start_game(room_key)
  sio.emit('start_game', {"seed" : randrange(10000)}, room=room_key)

@sio.event
def register_vote(sid, data):
  title, vote = data["title"], data["vote"]
  room_key = [room for room in sio.rooms(sid) if room != sid][0]
  if room_tracker.submit_vote(sid, room_key, title, vote):
    sio.emit("pick_movie", {"title" : title}, room=room_key)

def get_username(sid:str) -> str:
  with sio.session(sid) as session:
    username = session["username"]
  return username

def make_dicts(cursor, row):
  return dict((cursor.description[idx][0], value)
              for idx, value in enumerate(row))

def get_db():
  db = getattr(g, '_database', None)
  if db is None:
    db = g._database = sqlite3.connect("movies.db")
    db.row_factory = make_dicts
  return db

def query_db(query, args=(), one=False):
  cursor = get_db().execute(query, args)
  rv = cursor.fetchall()
  cursor.close()
  return (rv[0] if rv else None) if one else rv

def get_id_range():
  query = "SELECT MAX(id) from movies"
  return query_db(query)

def get_movies(ids: tuple):
  query = "SELECT * FROM movies WHERE id in ({})"
  placeholders = ", ".join(["?" for _ in ids])
  query = query.format(placeholders)
  return query_db(query, ids)

@pp.teardown_appcontext
def close_connection(exception):
  db = getattr(g, '_database', None)
  if db is not None:
    db.close()

# -- Http Endpoints -- 
# TODO: rename flask app from 'pp' to something mature, sensible and descriptive
# TODO: what method should this be
# TODO: should this be http or socket event?
@pp.route('/create_room', methods=['POST'])
def create_room():
  room_key = room_tracker.create_room()
  return {"room_key" : room_key}

@pp.route("/movies", methods=["GET"])
def movies():
  seed = request.args.get("seed")
  random.seed(seed)
  id_range = get_id_range()[0]["MAX(id)"]
  ids = random.sample(range(1, id_range), 5)
  movies = get_movies(ids)
  return movies 